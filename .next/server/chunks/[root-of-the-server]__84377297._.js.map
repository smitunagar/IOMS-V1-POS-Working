{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alvi/IOMS/IOMS_V1_POS_Working_main_20_08_2025/src/app/api/inventory/low-stock/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    // Get query parameters for filtering\r\n    const { searchParams } = new URL(request.url);\r\n    const threshold = parseInt(searchParams.get('threshold') || '10');\r\n    const category = searchParams.get('category');\r\n\r\n    // Base query for low stock items\r\n    let whereClause: any = {\r\n      quantity: {\r\n        lte: threshold\r\n      }\r\n    };\r\n\r\n    // Note: Category filtering would need to be implemented at the ingredient level\r\n    // if categories are added to the ingredient model in the future\r\n\r\n    // Fetch low stock items from inventory with ingredient details\r\n    const lowStockItems = await prisma.inventory.findMany({\r\n      where: whereClause,\r\n      select: {\r\n        id: true,\r\n        quantity: true,\r\n        lastUpdated: true,\r\n        ingredient: {\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            unit: true\r\n          }\r\n        }\r\n      },\r\n      orderBy: [\r\n        { quantity: 'asc' }\r\n      ]\r\n    });\r\n\r\n    // Calculate additional metrics\r\n    const totalLowStockItems = lowStockItems.length;\r\n    const criticalItems = lowStockItems.filter(item => item.quantity <= 5);\r\n\r\n    // Transform data for frontend consumption\r\n    const formattedItems = lowStockItems.map(item => ({\r\n      id: item.id,\r\n      name: item.ingredient.name,\r\n      quantity: item.quantity,\r\n      unit: item.ingredient.unit || 'units',\r\n      lastUpdated: item.lastUpdated,\r\n      ingredientId: item.ingredient.id\r\n    }));\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      data: {\r\n        items: formattedItems,\r\n        summary: {\r\n          totalLowStockItems,\r\n          criticalItems: criticalItems.length,\r\n          threshold\r\n        }\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching low stock items:', error);\r\n    return NextResponse.json(\r\n      { \r\n        success: false, \r\n        error: 'Failed to fetch low stock items',\r\n        details: error instanceof Error ? error.message : 'Unknown error'\r\n      },\r\n      { status: 500 }\r\n    );\r\n  } finally {\r\n    await prisma.$disconnect();\r\n  }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = await request.json();\r\n    const { itemId, newQuantity, restockNote } = body;\r\n\r\n    if (!itemId || newQuantity === undefined) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Item ID and new quantity are required' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Update inventory item quantity\r\n    const updatedItem = await prisma.inventory.update({\r\n      where: { id: itemId },\r\n      data: {\r\n        quantity: newQuantity,\r\n        lastUpdated: new Date()\r\n      },\r\n      include: {\r\n        ingredient: true\r\n      }\r\n    });\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      data: updatedItem,\r\n      message: 'Item successfully restocked'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error restocking item:', error);\r\n    return NextResponse.json(\r\n      { \r\n        success: false, \r\n        error: 'Failed to restock item',\r\n        details: error instanceof Error ? error.message : 'Unknown error'\r\n      },\r\n      { status: 500 }\r\n    );\r\n  } finally {\r\n    await prisma.$disconnect();\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA,MAAM,SAAS,IAAI,6IAAY;AAExB,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,qCAAqC;QACrC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,YAAY,SAAS,aAAa,GAAG,CAAC,gBAAgB;QAC5D,MAAM,WAAW,aAAa,GAAG,CAAC;QAElC,iCAAiC;QACjC,IAAI,cAAmB;YACrB,UAAU;gBACR,KAAK;YACP;QACF;QAEA,gFAAgF;QAChF,gEAAgE;QAEhE,+DAA+D;QAC/D,MAAM,gBAAgB,MAAM,OAAO,SAAS,CAAC,QAAQ,CAAC;YACpD,OAAO;YACP,QAAQ;gBACN,IAAI;gBACJ,UAAU;gBACV,aAAa;gBACb,YAAY;oBACV,QAAQ;wBACN,IAAI;wBACJ,MAAM;wBACN,MAAM;oBACR;gBACF;YACF;YACA,SAAS;gBACP;oBAAE,UAAU;gBAAM;aACnB;QACH;QAEA,+BAA+B;QAC/B,MAAM,qBAAqB,cAAc,MAAM;QAC/C,MAAM,gBAAgB,cAAc,MAAM,CAAC,CAAA,OAAQ,KAAK,QAAQ,IAAI;QAEpE,0CAA0C;QAC1C,MAAM,iBAAiB,cAAc,GAAG,CAAC,CAAA,OAAQ,CAAC;gBAChD,IAAI,KAAK,EAAE;gBACX,MAAM,KAAK,UAAU,CAAC,IAAI;gBAC1B,UAAU,KAAK,QAAQ;gBACvB,MAAM,KAAK,UAAU,CAAC,IAAI,IAAI;gBAC9B,aAAa,KAAK,WAAW;gBAC7B,cAAc,KAAK,UAAU,CAAC,EAAE;YAClC,CAAC;QAED,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,MAAM;gBACJ,OAAO;gBACP,SAAS;oBACP;oBACA,eAAe,cAAc,MAAM;oBACnC;gBACF;YACF;QACF;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD,GACA;YAAE,QAAQ;QAAI;IAElB,SAAU;QACR,MAAM,OAAO,WAAW;IAC1B;AACF;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,WAAW,EAAE,GAAG;QAE7C,IAAI,CAAC,UAAU,gBAAgB,WAAW;YACxC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO;YAAwC,GACjE;gBAAE,QAAQ;YAAI;QAElB;QAEA,iCAAiC;QACjC,MAAM,cAAc,MAAM,OAAO,SAAS,CAAC,MAAM,CAAC;YAChD,OAAO;gBAAE,IAAI;YAAO;YACpB,MAAM;gBACJ,UAAU;gBACV,aAAa,IAAI;YACnB;YACA,SAAS;gBACP,YAAY;YACd;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,MAAM;YACN,SAAS;QACX;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD,GACA;YAAE,QAAQ;QAAI;IAElB,SAAU;QACR,MAAM,OAAO,WAAW;IAC1B;AACF","debugId":null}}]
}