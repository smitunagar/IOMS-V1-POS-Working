// Advanced Procurement Workflow Service
// Handles quotation requests, owner approvals, and purchase order generation

export interface ProcurementWorkflow {
  quotationRequests: QuotationRequest[];
  ownerApprovals: OwnerApproval[];
  purchaseOrders: PurchaseOrder[];
  workflowSettings: WorkflowSettings;
}

export interface QuotationRequest {
  id: string;
  itemId: string;
  itemName: string;
  quantity: number;
  unit: string;
  urgencyLevel: 'low' | 'medium' | 'high' | 'critical';
  requestedVendors: string[];
  requestDate: string;
  requiredDeliveryDate: string;
  specifications: string;
  estimatedBudget: number;
  status: 'draft' | 'sent' | 'responded' | 'expired';
  responses: QuotationResponse[];
  createdBy: string;
  daysUntilStockout: number;
  autoGenerated: boolean;
}

export interface QuotationResponse {
  id: string;
  quotationRequestId: string;
  vendorId: string;
  vendorName: string;
  unitPrice: number;
  totalPrice: number;
  deliveryTime: string;
  validUntil: string;
  paymentTerms: string;
  notes: string;
  receivedDate: string;
  status: 'pending' | 'evaluated' | 'selected' | 'rejected';
  attachments: string[];
}

export interface OwnerApproval {
  id: string;
  quotationRequestId: string;
  selectedQuotationId: string;
  requestedBy: string;
  requestDate: string;
  approvalDate?: string;
  status: 'pending' | 'approved' | 'rejected' | 'escalated';
  approvedBy?: string;
  rejectionReason?: string;
  urgencyLevel: 'low' | 'medium' | 'high' | 'critical';
  totalAmount: number;
  vendor: string;
  item: string;
  quantity: number;
  budgetImpact: 'within_budget' | 'over_budget' | 'requires_review';
  autoApprovalEligible: boolean;
}

export interface PurchaseOrder {
  id: string;
  orderNumber: string;
  quotationRequestId: string;
  quotationResponseId: string;
  ownerApprovalId: string;
  vendorId: string;
  vendorName: string;
  vendorContact: VendorContact;
  orderDate: string;
  requiredDeliveryDate: string;
  estimatedDeliveryDate: string;
  items: PurchaseOrderItem[];
  subtotal: number;
  taxAmount: number;
  totalAmount: number;
  paymentTerms: string;
  deliveryAddress: string;
  specialInstructions: string;
  status: 'draft' | 'sent' | 'acknowledged' | 'delivered' | 'invoiced' | 'paid' | 'cancelled';
  trackingInfo?: TrackingInfo;
  createdBy: string;
  approvedBy: string;
}

export interface PurchaseOrderItem {
  itemId: string;
  itemName: string;
  description: string;
  quantity: number;
  unit: string;
  unitPrice: number;
  totalPrice: number;
  specifications: string;
}

export interface VendorContact {
  name: string;
  email: string;
  phone: string;
  address: string;
  contactPerson: string;
}

export interface TrackingInfo {
  carrier: string;
  trackingNumber: string;
  estimatedDelivery: string;
  status: string;
  lastUpdate: string;
}

export interface WorkflowSettings {
  baseThresholdDays: number; // 15 days default
  autoQuotationThreshold: number; // Auto-request quotes when stock < X days
  ownerApprovalThreshold: number; // Amount requiring owner approval
  autoApprovalLimit: number; // Auto-approve up to this amount
  quotationValidityDays: number; // How long quotes remain valid
  emailSettings: EmailSettings;
  escalationRules: EscalationRule[];
}

export interface EmailSettings {
  ownerEmail: string;
  procurementEmail: string;
  ccEmails: string[];
  emailTemplates: EmailTemplates;
  smtpConfig: SMTPConfig;
}

export interface EmailTemplates {
  quotationRequest: string;
  ownerApprovalRequest: string;
  approvalNotification: string;
  purchaseOrderConfirmation: string;
  deliveryReminder: string;
}

export interface SMTPConfig {
  host: string;
  port: number;
  secure: boolean;
  username: string;
  password: string;
}

export interface EscalationRule {
  condition: 'overdue_approval' | 'no_response' | 'critical_stockout';
  timeThreshold: number; // hours
  escalateTo: string[];
  action: 'email' | 'sms' | 'call';
}

class ProcurementWorkflowService {
  private static instance: ProcurementWorkflowService;
  private quotationRequests: Map<string, QuotationRequest> = new Map();
  private ownerApprovals: Map<string, OwnerApproval> = new Map();
  private purchaseOrders: Map<string, PurchaseOrder> = new Map();
  private workflowSettings: WorkflowSettings;

  public static getInstance(): ProcurementWorkflowService {
    if (!ProcurementWorkflowService.instance) {
      ProcurementWorkflowService.instance = new ProcurementWorkflowService();
    }
    return ProcurementWorkflowService.instance;
  }

  constructor() {
    this.initializeWorkflowSettings();
    this.setupAutoMonitoring();
  }

  private initializeWorkflowSettings() {
    this.workflowSettings = {
      baseThresholdDays: 15, // Base threshold for automatic quotation requests
      autoQuotationThreshold: 7, // Auto-request quotes when stock < 7 days
      ownerApprovalThreshold: 500, // Amounts over €500 need owner approval
      autoApprovalLimit: 200, // Auto-approve up to €200
      quotationValidityDays: 30,
      emailSettings: {
        ownerEmail: 'owner@museum-restaurant-hechingen.com',
        procurementEmail: 'procurement@museum-restaurant-hechingen.com',
        ccEmails: ['manager@museum-restaurant-hechingen.com'],
        emailTemplates: {
          quotationRequest: this.getQuotationRequestTemplate(),
          ownerApprovalRequest: this.getOwnerApprovalTemplate(),
          approvalNotification: this.getApprovalNotificationTemplate(),
          purchaseOrderConfirmation: this.getPurchaseOrderTemplate(),
          deliveryReminder: this.getDeliveryReminderTemplate()
        },
        smtpConfig: {
          host: 'smtp.gmail.com',
          port: 587,
          secure: false,
          username: 'procurement@museum-restaurant-hechingen.com',
          password: process.env.SMTP_PASSWORD || ''
        }
      },
      escalationRules: [
        {
          condition: 'overdue_approval',
          timeThreshold: 24, // 24 hours
          escalateTo: ['owner@museum-restaurant-hechingen.com'],
          action: 'email'
        },
        {
          condition: 'critical_stockout',
          timeThreshold: 2, // 2 hours
          escalateTo: ['owner@museum-restaurant-hechingen.com', 'manager@museum-restaurant-hechingen.com'],
          action: 'email'
        }
      ]
    };
  }

  private setupAutoMonitoring() {
    // Monitor inventory levels every hour
    setInterval(() => {
      this.checkInventoryThresholds();
    }, 3600000); // 1 hour

    // Check for overdue approvals every 30 minutes
    setInterval(() => {
      this.checkOverdueApprovals();
    }, 1800000); // 30 minutes
  }

  // AUTOMATIC QUOTATION REQUEST SYSTEM
  public async checkInventoryThresholds() {
    console.log('[Procurement Workflow] Checking inventory thresholds...');
    
    // Get current inventory levels from SupplySync
    const { supplySyncService } = await import('./supplySyncService');
    const analysis = await supplySyncService.analyzeSupplyChain();
    
    for (const alert of analysis.inventoryAlerts) {
      if (alert.daysUntilStockout <= this.workflowSettings.autoQuotationThreshold) {
        await this.autoGenerateQuotationRequest(alert);
      }
    }
  }

  private async autoGenerateQuotationRequest(alert: any) {
    const existingRequest = Array.from(this.quotationRequests.values())
      .find(req => req.itemId === alert.itemId && req.status !== 'expired');

    if (existingRequest) {
      console.log(`[Procurement] Quotation request already exists for ${alert.itemName}`);
      return;
    }

    const quotationRequest: QuotationRequest = {
      id: `qr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      itemId: alert.itemId,
      itemName: alert.itemName,
      quantity: alert.suggestedOrderQuantity,
      unit: 'kg', // Default unit
      urgencyLevel: alert.urgencyLevel,
      requestedVendors: this.selectVendorsForQuotation(alert.category),
      requestDate: new Date().toISOString(),
      requiredDeliveryDate: this.calculateRequiredDeliveryDate(alert.daysUntilStockout),
      specifications: this.generateSpecifications(alert.itemName),
      estimatedBudget: alert.estimatedCost,
      status: 'draft',
      responses: [],
      createdBy: 'SupplySync Bot',
      daysUntilStockout: alert.daysUntilStockout,
      autoGenerated: true
    };

    this.quotationRequests.set(quotationRequest.id, quotationRequest);
    
    // Send quotation requests to vendors
    await this.sendQuotationRequests(quotationRequest);
    
    console.log(`[Procurement] Auto-generated quotation request for ${alert.itemName} (${alert.daysUntilStockout} days left)`);
  }

  // QUOTATION MANAGEMENT
  public async sendQuotationRequests(quotationRequest: QuotationRequest): Promise<boolean> {
    try {
      quotationRequest.status = 'sent';
      
      // Send emails to all requested vendors
      for (const vendorId of quotationRequest.requestedVendors) {
        await this.sendVendorQuotationEmail(quotationRequest, vendorId);
      }

      // Update database
      this.quotationRequests.set(quotationRequest.id, quotationRequest);
      
      return true;
    } catch (error) {
      console.error('[Procurement] Failed to send quotation requests:', error);
      return false;
    }
  }

  public async receiveQuotationResponse(response: QuotationResponse): Promise<boolean> {
    try {
      const quotationRequest = this.quotationRequests.get(response.quotationRequestId);
      if (!quotationRequest) {
        throw new Error('Quotation request not found');
      }

      quotationRequest.responses.push(response);
      quotationRequest.status = 'responded';
      
      this.quotationRequests.set(quotationRequest.id, quotationRequest);

      // Check if all vendors have responded or if we have enough responses
      if (this.shouldProceedWithEvaluation(quotationRequest)) {
        await this.evaluateQuotationsAndRequestApproval(quotationRequest);
      }

      return true;
    } catch (error) {
      console.error('[Procurement] Failed to process quotation response:', error);
      return false;
    }
  }

  // OWNER APPROVAL SYSTEM
  private async evaluateQuotationsAndRequestApproval(quotationRequest: QuotationRequest) {
    // Select best quotation based on criteria
    const bestQuotation = this.selectBestQuotation(quotationRequest.responses);
    
    if (!bestQuotation) {
      console.error('[Procurement] No valid quotations found');
      return;
    }

    const approval: OwnerApproval = {
      id: `ap_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      quotationRequestId: quotationRequest.id,
      selectedQuotationId: bestQuotation.id,
      requestedBy: 'SupplySync Bot',
      requestDate: new Date().toISOString(),
      status: 'pending',
      urgencyLevel: quotationRequest.urgencyLevel,
      totalAmount: bestQuotation.totalPrice,
      vendor: bestQuotation.vendorName,
      item: quotationRequest.itemName,
      quantity: quotationRequest.quantity,
      budgetImpact: this.assessBudgetImpact(bestQuotation.totalPrice, quotationRequest.estimatedBudget),
      autoApprovalEligible: bestQuotation.totalPrice <= this.workflowSettings.autoApprovalLimit
    };

    this.ownerApprovals.set(approval.id, approval);

    // Auto-approve if eligible, otherwise request owner approval
    if (approval.autoApprovalEligible && approval.urgencyLevel !== 'critical') {
      await this.autoApproveQuotation(approval.id);
    } else {
      await this.requestOwnerApproval(approval);
    }
  }

  private selectBestQuotation(responses: QuotationResponse[]): QuotationResponse | null {
    if (responses.length === 0) return null;

    // Score quotations based on multiple factors
    const scoredQuotations = responses.map(response => ({
      response,
      score: this.calculateQuotationScore(response)
    }));

    scoredQuotations.sort((a, b) => b.score - a.score);
    return scoredQuotations[0].response;
  }

  private calculateQuotationScore(response: QuotationResponse): number {
    // Scoring factors (lower price = higher score, faster delivery = higher score)
    const priceScore = Math.max(0, 100 - (response.unitPrice * 10)); // Simplified
    const deliveryScore = this.getDeliveryScore(response.deliveryTime);
    const vendorScore = this.getVendorReliabilityScore(response.vendorId);
    
    return (priceScore * 0.5) + (deliveryScore * 0.3) + (vendorScore * 0.2);
  }

  public async requestOwnerApproval(approval: OwnerApproval): Promise<boolean> {
    try {
      // Send email to owner
      await this.sendOwnerApprovalEmail(approval);
      
      console.log(`[Procurement] Owner approval requested for ${approval.item} - €${approval.totalAmount}`);
      return true;
    } catch (error) {
      console.error('[Procurement] Failed to request owner approval:', error);
      return false;
    }
  }

  public async processOwnerApproval(approvalId: string, decision: 'approved' | 'rejected', approvedBy: string, reason?: string): Promise<boolean> {
    try {
      const approval = this.ownerApprovals.get(approvalId);
      if (!approval) {
        throw new Error('Approval request not found');
      }

      approval.status = decision;
      approval.approvedBy = approvedBy;
      approval.approvalDate = new Date().toISOString();
      if (reason) approval.rejectionReason = reason;

      this.ownerApprovals.set(approvalId, approval);

      if (decision === 'approved') {
        // Generate purchase order
        await this.generatePurchaseOrder(approval);
      } else {
        // Handle rejection - may need to find alternative vendors
        await this.handleApprovalRejection(approval);
      }

      return true;
    } catch (error) {
      console.error('[Procurement] Failed to process owner approval:', error);
      return false;
    }
  }

  private async autoApproveQuotation(approvalId: string): Promise<boolean> {
    return this.processOwnerApproval(approvalId, 'approved', 'System Auto-Approval');
  }

  // PURCHASE ORDER GENERATION
  public async generatePurchaseOrder(approval: OwnerApproval): Promise<PurchaseOrder | null> {
    try {
      const quotationRequest = this.quotationRequests.get(approval.quotationRequestId);
      const selectedQuotation = quotationRequest?.responses.find(r => r.id === approval.selectedQuotationId);
      
      if (!quotationRequest || !selectedQuotation) {
        throw new Error('Required data not found for PO generation');
      }

      const orderNumber = this.generateOrderNumber();
      const vendor = await this.getVendorDetails(selectedQuotation.vendorId);
      
      const purchaseOrder: PurchaseOrder = {
        id: `po_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        orderNumber,
        quotationRequestId: quotationRequest.id,
        quotationResponseId: selectedQuotation.id,
        ownerApprovalId: approval.id,
        vendorId: selectedQuotation.vendorId,
        vendorName: selectedQuotation.vendorName,
        vendorContact: vendor.contact,
        orderDate: new Date().toISOString(),
        requiredDeliveryDate: quotationRequest.requiredDeliveryDate,
        estimatedDeliveryDate: this.calculateEstimatedDeliveryDate(selectedQuotation.deliveryTime),
        items: [{
          itemId: quotationRequest.itemId,
          itemName: quotationRequest.itemName,
          description: quotationRequest.specifications,
          quantity: quotationRequest.quantity,
          unit: quotationRequest.unit,
          unitPrice: selectedQuotation.unitPrice,
          totalPrice: selectedQuotation.totalPrice,
          specifications: quotationRequest.specifications
        }],
        subtotal: selectedQuotation.totalPrice,
        taxAmount: selectedQuotation.totalPrice * 0.19, // 19% VAT
        totalAmount: selectedQuotation.totalPrice * 1.19,
        paymentTerms: selectedQuotation.paymentTerms,
        deliveryAddress: 'Museum Restaurant Hechingen, Hechingen, Germany',
        specialInstructions: this.generateDeliveryInstructions(quotationRequest.urgencyLevel),
        status: 'draft',
        createdBy: 'SupplySync Bot',
        approvedBy: approval.approvedBy || 'System'
      };

      this.purchaseOrders.set(purchaseOrder.id, purchaseOrder);

      // Send PO to vendor
      await this.sendPurchaseOrderToVendor(purchaseOrder);
      
      console.log(`[Procurement] Purchase Order ${orderNumber} generated for ${quotationRequest.itemName}`);
      return purchaseOrder;
    } catch (error) {
      console.error('[Procurement] Failed to generate purchase order:', error);
      return null;
    }
  }

  // EMAIL NOTIFICATION SYSTEM
  private async sendVendorQuotationEmail(quotationRequest: QuotationRequest, vendorId: string): Promise<boolean> {
    // Simulate email sending
    console.log(`[Email] Quotation request sent to vendor ${vendorId} for ${quotationRequest.itemName}`);
    
    const emailContent = this.workflowSettings.emailSettings.emailTemplates.quotationRequest
      .replace('{ITEM_NAME}', quotationRequest.itemName)
      .replace('{QUANTITY}', quotationRequest.quantity.toString())
      .replace('{DELIVERY_DATE}', quotationRequest.requiredDeliveryDate)
      .replace('{SPECIFICATIONS}', quotationRequest.specifications);

    // In real implementation, send actual email here
    return true;
  }

  private async sendOwnerApprovalEmail(approval: OwnerApproval): Promise<boolean> {
    console.log(`[Email] Owner approval request sent for ${approval.item} - €${approval.totalAmount}`);
    
    const emailContent = this.workflowSettings.emailSettings.emailTemplates.ownerApprovalRequest
      .replace('{ITEM_NAME}', approval.item)
      .replace('{VENDOR}', approval.vendor)
      .replace('{AMOUNT}', approval.totalAmount.toString())
      .replace('{URGENCY}', approval.urgencyLevel);

    return true;
  }

  private async sendPurchaseOrderToVendor(purchaseOrder: PurchaseOrder): Promise<boolean> {
    console.log(`[Email] Purchase Order ${purchaseOrder.orderNumber} sent to ${purchaseOrder.vendorName}`);
    
    purchaseOrder.status = 'sent';
    this.purchaseOrders.set(purchaseOrder.id, purchaseOrder);
    
    return true;
  }

  // UTILITY METHODS
  private selectVendorsForQuotation(category: string): string[] {
    // Select 2-3 vendors based on category specialization
    const vendorCategories: { [key: string]: string[] } = {
      'meat': ['vendor_002', 'vendor_001'],
      'vegetables': ['vendor_001', 'vendor_002'],
      'spices': ['vendor_004', 'vendor_003'],
      'dairy': ['vendor_001', 'vendor_003']
    };

    return vendorCategories[category?.toLowerCase()] || ['vendor_001', 'vendor_002'];
  }

  private calculateRequiredDeliveryDate(daysUntilStockout: number): string {
    const deliveryDate = new Date();
    deliveryDate.setDate(deliveryDate.getDate() + Math.max(1, Math.floor(daysUntilStockout * 0.8)));
    return deliveryDate.toISOString();
  }

  private generateSpecifications(itemName: string): string {
    const specifications: { [key: string]: string } = {
      'Chicken Breast': 'Fresh, Grade A, hormone-free, vacuum packed',
      'Fresh Tomatoes': 'Vine-ripened, Grade 1, medium size',
      'Garam Masala': 'Premium blend, sealed packaging, 6-month shelf life',
      'Basmati Rice': 'Aged 1 year, long grain, premium quality'
    };

    return specifications[itemName] || 'Standard restaurant quality';
  }

  private generateOrderNumber(): string {
    const date = new Date();
    const year = date.getFullYear().toString().substr(-2);
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const sequence = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
    
    return `PO${year}${month}${day}-${sequence}`;
  }

  private shouldProceedWithEvaluation(quotationRequest: QuotationRequest): boolean {
    const hoursWaiting = (Date.now() - new Date(quotationRequest.requestDate).getTime()) / 3600000;
    
    // Proceed if we have at least 2 responses or we've waited more than 24 hours
    return quotationRequest.responses.length >= 2 || hoursWaiting > 24;
  }

  private assessBudgetImpact(actualCost: number, estimatedCost: number): 'within_budget' | 'over_budget' | 'requires_review' {
    const variance = (actualCost - estimatedCost) / estimatedCost;
    
    if (variance <= 0.1) return 'within_budget';
    if (variance <= 0.25) return 'requires_review';
    return 'over_budget';
  }

  private checkOverdueApprovals() {
    const now = Date.now();
    
    for (const approval of this.ownerApprovals.values()) {
      if (approval.status === 'pending') {
        const hoursOverdue = (now - new Date(approval.requestDate).getTime()) / 3600000;
        
        if (hoursOverdue > 24) {
          this.escalateApproval(approval);
        }
      }
    }
  }

  private async escalateApproval(approval: OwnerApproval) {
    console.log(`[Procurement] Escalating overdue approval for ${approval.item}`);
    approval.status = 'escalated';
    this.ownerApprovals.set(approval.id, approval);
  }

  private async handleApprovalRejection(approval: OwnerApproval) {
    console.log(`[Procurement] Approval rejected for ${approval.item}. Reason: ${approval.rejectionReason}`);
    // Could implement logic to find alternative vendors or adjust requirements
  }

  // Email templates
  private getQuotationRequestTemplate(): string {
    return `
      Subject: Quotation Request - {ITEM_NAME}
      
      Dear Vendor,
      
      We are requesting a quotation for the following item:
      
      Item: {ITEM_NAME}
      Quantity: {QUANTITY}
      Required Delivery Date: {DELIVERY_DATE}
      Specifications: {SPECIFICATIONS}
      
      Please provide your best price and delivery terms.
      
      Best regards,
      Museum Restaurant Hechingen
    `;
  }

  private getOwnerApprovalTemplate(): string {
    return `
      Subject: Purchase Approval Required - {ITEM_NAME}
      
      Dear Owner,
      
      A purchase approval is required for:
      
      Item: {ITEM_NAME}
      Vendor: {VENDOR}
      Amount: €{AMOUNT}
      Urgency: {URGENCY}
      
      Please review and approve this purchase.
      
      Best regards,
      SupplySync Bot
    `;
  }

  private getApprovalNotificationTemplate(): string {
    return `Purchase approval notification template`;
  }

  private getPurchaseOrderTemplate(): string {
    return `Purchase order confirmation template`;
  }

  private getDeliveryReminderTemplate(): string {
    return `Delivery reminder template`;
  }

  private getDeliveryScore(deliveryTime: string): number {
    // Convert delivery time to score (faster = higher score)
    if (deliveryTime.includes('same day')) return 100;
    if (deliveryTime.includes('1-2 days')) return 80;
    if (deliveryTime.includes('2-3 days')) return 60;
    return 40;
  }

  private getVendorReliabilityScore(vendorId: string): number {
    // Get vendor reliability from SupplySync service
    return 85; // Default score
  }

  private async getVendorDetails(vendorId: string): Promise<any> {
    // Return vendor contact details
    return {
      contact: {
        name: 'Sample Vendor',
        email: 'vendor@example.com',
        phone: '+49 123 456789',
        address: 'Vendor Address',
        contactPerson: 'Sales Manager'
      }
    };
  }

  private calculateEstimatedDeliveryDate(deliveryTime: string): string {
    const days = deliveryTime.includes('same day') ? 0 : 
                  deliveryTime.includes('1-2') ? 2 :
                  deliveryTime.includes('2-3') ? 3 : 5;
    
    const deliveryDate = new Date();
    deliveryDate.setDate(deliveryDate.getDate() + days);
    return deliveryDate.toISOString();
  }

  private generateDeliveryInstructions(urgencyLevel: string): string {
    if (urgencyLevel === 'critical') {
      return 'URGENT DELIVERY REQUIRED - Please prioritize this order';
    }
    return 'Standard delivery to main entrance during business hours';
  }

  // Public API methods
  public getQuotationRequests(): QuotationRequest[] {
    return Array.from(this.quotationRequests.values());
  }

  public getOwnerApprovals(): OwnerApproval[] {
    return Array.from(this.ownerApprovals.values());
  }

  public getPurchaseOrders(): PurchaseOrder[] {
    return Array.from(this.purchaseOrders.values());
  }

  public getWorkflowSettings(): WorkflowSettings {
    return this.workflowSettings;
  }

  public updateWorkflowSettings(settings: Partial<WorkflowSettings>): void {
    this.workflowSettings = { ...this.workflowSettings, ...settings };
  }
}

export { ProcurementWorkflowService };
export default ProcurementWorkflowService;
export const procurementWorkflowService = ProcurementWorkflowService.getInstance();
